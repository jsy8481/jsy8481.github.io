---
title: "02. Jotai 심화"
description: "이 가이드에서는 Jotai의 강력한 유틸리티(`jotai/utils`)와 비동기 처리, 그리고 성능 최적화 기법에 대해 다룹니다."
date: "2026-02-16"
---

이 가이드에서는 Jotai의 강력한 유틸리티(`jotai/utils`)와 비동기 처리, 그리고 성능 최적화 기법에 대해 다룹니다.

---

## 유틸리티 (Utilities)

Jotai는 상태 관리의 일반적인 패턴을 쉽게 구현할 수 있도록 다양한 유틸리티 함수를 제공합니다.

### 1. localStorage 동기화 (atomWithStorage)

`atomWithStorage`는 atom의 값을 `localStorage` (또는 `sessionStorage`)와 자동으로 동기화합니다. 페이지를 새로고침하거나 브라우저를 닫았다 열어도 상태가 유지됩니다.

```tsx
import { useAtom } from 'jotai';
import { atomWithStorage } from 'jotai/utils';

// 'theme' 키로 localStorage에 저장, 기본값 'light'
const themeAtom = atomWithStorage<'light' | 'dark'>('theme', 'light');

function ThemeToggle() {
  const [theme, setTheme] = useAtom(themeAtom);
  
  return (
    <button onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}>
      현재 모드: {theme}
    </button>
  );
}
```

**특징:**
- 값이 변경되면 자동으로 스토리지에 저장됩니다.
- 다른 탭에서 값이 변경되면 이를 감지하고 현재 탭의 상태도 업데이트합니다 (Cross-tab synchronization).
- SSR 지원을 위해 `createJSONStorage` 등의 옵션을 제공합니다.

### 2. 상태 초기화 (atomWithReset)

복잡한 폼이나 필터 상태를 초기값으로 되돌려야 할 때 유용합니다. `RESET` 심볼을 사용하여 간편하게 초기화할 수 있습니다.

```tsx
import { atomWithReset, useResetAtom } from 'jotai/utils';
import { useAtom } from 'jotai';

// 초기값 지정
const filterAtom = atomWithReset({ keyword: '', sort: 'date' });

function FilterComponent() {
  const [filter, setFilter] = useAtom(filterAtom);
  // 초기화 함수만 가져오기
  const resetFilter = useResetAtom(filterAtom);
  
  return (
    <div>
      <input 
        value={filter.keyword} 
        onChange={(e) => setFilter(prev => ({ ...prev, keyword: e.target.value }))} 
        placeholder="키워드" 
      />
      <button onClick={resetFilter}>필터 초기화</button>
    </div>
  );
}
```

### 3. 동적 Atom 생성 (atomFamily)

`atomFamily`는 파라미터를 받아 atom을 동적으로 생성하는 "Atom 공장"입니다. 같은 파라미터로 호출하면 항상 **동일한 atom 인스턴스** 를 반환(메모이제이션)합니다.

**언제 필요한가?**
- 사용자 ID별 프로필 데이터
- 리스트의 각 아이템별 상태 (예: 좋아요 여부)

```tsx
import { atomFamily } from 'jotai/utils';
import { atom, useAtom } from 'jotai';

// ID를 받아서 해당 ID를 위한 atom을 생성
const userAtomFamily = atomFamily((id: number) => 
  atom({ id, name: 'Loading...', isActive: false })
);

function UserProfile({ userId }: { userId: number }) {
  // userId가 같으면 언제나 같은 atom을 참조합니다.
  const [user, setUser] = useAtom(userAtomFamily(userId));
  
  return <div>{user.name}</div>;
}
```

---

## 비동기 처리 (Async)

Jotai의 Atom은 비동기 로직(Promise)을 자연스럽게 다룰 수 있습니다.

### 1. 기본 비동기 Atom

Atom의 읽기 함수(`read`)를 `async` 함수로 만들면 됩니다. Jotai는 React `Suspense`와 완벽하게 통합됩니다.

```tsx
import { atom, useAtomValue } from 'jotai';
import { Suspense } from 'react';

const userIdAtom = atom(1);

// 비동기 파생 atom
const userProfileAtom = atom(async (get) => {
  const id = get(userIdAtom);
  const response = await fetch(`https://api.example.com/users/${id}`);
  return response.json();
});

function UserProfile() {
  const user = useAtomValue(userProfileAtom); // 데이터가 준비될 때까지 Suspend
  return <div>{user.name}</div>;
}

function App() {
  return (
    <Suspense fallback={<div>로딩 중...</div>}>
      <UserProfile />
    </Suspense>
  );
}
```

### 2. TanStack Query 통합

단순한 데이터 페칭을 넘어 캐싱, 리페칭, 무한 스크롤 등이 필요하다면 `jotai-tanstack-query` 확장을 사용하는 것이 좋습니다.

> 자세한 내용은 [TanStack Query 가이드](../tanstack-query/start-guide/01-basics.md)를 참고하세요.

---

## 성능 최적화 (Performance)

큰 객체나 리스트를 다룰 때 불필요한 리렌더링을 방지하는 기법들입니다.

### 1. 객체의 일부만 구독 (selectAtom)

큰 객체 상태에서 특정 프로퍼티만 필요할 때 사용합니다. 값이 변하지 않으면 리렌더링되지 않습니다 (Read-only).

```tsx
import { atom, useAtomValue } from 'jotai';
import { selectAtom } from 'jotai/utils';

const formAtom = atom({ name: 'Kim', age: 30, address: 'Seoul' });

// name이 바뀔 때만 리렌더링
const nameAtom = selectAtom(formAtom, (state) => state.name);

function DisplayName() {
  const name = useAtomValue(nameAtom); // name만 구독
  return <p>이름: {name}</p>;
}
```

### 2. 객체 깊은 곳 수정 (focusAtom)

객체의 깊은 곳을 수정할 때 불변성을 지키며 쉽게 업데이트하고, 해당 부분만 구독할 수 있게 해줍니다. `jotai-optics` 확장이 필요합니다.

```tsx
import { atom, useAtom } from 'jotai';
import { focusAtom } from 'jotai-optics'; // npm install jotai-optics

const formAtom = atom({
  name: 'Kim',
  profile: {
    address: { city: 'Seoul', street: 'Gangnam' }
  }
});

// address.city에만 집중하는 atom 생성
const cityAtom = focusAtom(formAtom, (optic) => 
  optic.prop('profile').prop('address').prop('city')
);

function CityInput() {
  // cityAtom을 통해 수정하면 원본 formAtom의 city만 깔끔하게 업데이트됨
  const [city, setCity] = useAtom(cityAtom);
  return <input value={city} onChange={e => setCity(e.target.value)} />;
}
```

### 3. 리스트 최적화 (splitAtom)

배열 데이터를 렌더링할 때, 아이템 하나가 변경되어도 리스트 전체가 리렌더링되는 것을 막아줍니다. 배열의 각 요소를 개별 atom으로 쪼개줍니다.

```tsx
import { atom, useAtom } from 'jotai';
import { splitAtom } from 'jotai/utils';

const todosAtom = atom([
  { id: 1, text: 'Study Jotai', done: false },
  { id: 2, text: 'Sleep', done: false },
]);

// 각 todo 아이템을 atom으로 변환
const todoAtomsAtom = splitAtom(todosAtom);

function TodoList() {
  const [todoAtoms] = useAtom(todoAtomsAtom);
  return (
    <div>
      {todoAtoms.map((todoAtom) => (
        // key는 atom 자체를 사용하거나, atom의 고유 ID를 사용
        <TodoItem key={`${todoAtom}`} todoAtom={todoAtom} />
      ))}
    </div>
  );
}

function TodoItem({ todoAtom }) {
  // 이 아이템의 상태가 변할 때만 이 컴포넌트가 리렌더링됨
  const [todo, setTodo] = useAtom(todoAtom);
  const toggle = () => setTodo((prev) => ({ ...prev, done: !prev.done }));
  
  return <div onClick={toggle}>{todo.text}</div>;
}
```

---

## 레퍼런스

- [Jotai Utils - Storage](https://jotai.org/docs/utilities/storage)
- [Jotai Utils - Resettable](https://jotai.org/docs/utilities/resettable)
- [Jotai Utils - Family](https://jotai.org/docs/utilities/family)
- [Jotai Guide - Async](https://jotai.org/docs/guides/async)
- [Jotai Optics](https://github.com/jotaijs/jotai-optics)

** 이전 장**: [01. Jotai 기초](./01-basics.md)
