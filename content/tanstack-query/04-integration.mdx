---
title: "04. Jotai + TanStack Query 통합 패턴"
description: "Jotai와 TanStack Query를 통합하여 서버 상태와 클라이언트 상태를 효율적으로 관리하는 패턴을 다룹니다."
date: "2026-02-16"
---

## 왜 두 도구를 함께 사용하나요?

### 역할 분담의 명확성

```
┌─────────────────────────────────────────────────────────────────┐
│                       사용자 인터페이스                          │
├──────────────────────────┬──────────────────────────────────────┤
│    Jotai (클라이언트)     │      TanStack Query (서버)           │
├──────────────────────────┼──────────────────────────────────────┤
│  • 선택된 필터            │  • API 데이터 페칭                   │
│  • 모달 열림/닫힘         │  • 캐싱 및 동기화                    │
│  • 현재 선택된 탭         │  • 로딩/에러 상태 관리               │
│  • 테마 설정              │  • 백그라운드 갱신                   │
│  • 임시 폼 상태           │  • 뮤테이션 처리                     │
└──────────────────────────┴──────────────────────────────────────┘
```

### 데이터 흐름

```
서버 DB → TanStack Query (페칭/캐싱) → React 컴포넌트
                                           ↕
                                      Jotai (필터/정렬)
                                           ↓
                                     화면에 표시될 데이터
```

---

## 패턴 1: Jotai로 필터, TanStack Query로 페칭

### 시나리오

주식 목록 화면에서:
- 사용자가 거래소(NASDAQ, NYSE), 섹터(Tech, Finance) 필터 선택
- 필터에 맞는 데이터를 서버에서 조회

### 구현

```tsx
// stores/stockFilter.ts
import { atom } from 'jotai';

// 필터 상태 (클라이언트 상태 - Jotai)
export const exchangeFilterAtom = atom<'ALL' | 'NASDAQ' | 'NYSE' | 'KRX'>('ALL');
export const sectorFilterAtom = atom<'ALL' | 'Tech' | 'Finance' | 'Healthcare'>('ALL');
export const sortByAtom = atom<'name' | 'price' | 'change'>('name');
```

**왜 Jotai로 필터를 관리하나요?**
- 필터는 **클라이언트에서만** 존재하는 UI 상태입니다
- 서버에 저장할 필요 없음 (새로고침 시 초기화되어도 됨)
- 여러 컴포넌트에서 공유해야 함 (필터 UI + 목록)

```tsx
// hooks/useStocks.ts
import { useAtomValue } from 'jotai';
import { useQuery } from '@tanstack/react-query';
import { exchangeFilterAtom, sectorFilterAtom } from '@/stores/stockFilter';

export function useStocks() {
  // 1. Jotai에서 현재 필터 값 읽기
  const exchange = useAtomValue(exchangeFilterAtom);
  const sector = useAtomValue(sectorFilterAtom);

  // 2. 필터를 쿼리 키에 포함 → 필터 변경 시 자동으로 새 쿼리 실행
  return useQuery({
    queryKey: ['stocks', { exchange, sector }],
    queryFn: () => stocksApi.getAll({ exchange, sector }),
    // 필터가 바뀌면 queryKey가 변경 → 새로운 쿼리 실행 또는 캐시 조회
  });
}
```

**핵심 포인트:**
- `queryKey`에 필터를 포함하면, **필터가 바뀔 때 자동으로** 새 데이터를 가져옵니다
- 같은 필터 조합은 캐시에서 즉시 반환 (네트워크 요청 없음)

```tsx
// components/StockList.tsx
function StockList() {
  const { data: stocks, isLoading, error } = useStocks();
  const sortBy = useAtomValue(sortByAtom);
  
  if (isLoading) return <Skeleton />;
  if (error) return <Error message={error.message} />;
  
  // 3. 서버 데이터에 클라이언트 정렬 적용
  const sortedStocks = [...stocks].sort((a, b) => {
    switch (sortBy) {
      case 'price': return b.price - a.price;
      case 'change': return b.changePercent - a.changePercent;
      default: return a.name.localeCompare(b.name);
    }
  });
  
  return (
    <ul>
      {sortedStocks.map(stock => (
        <StockItem key={stock.symbol} stock={stock} />
      ))}
    </ul>
  );
}
```

---

## 패턴 2: 선택 상태와 상세 조회

### 시나리오

- 목록에서 주식을 클릭하면 선택됨
- 선택된 주식의 상세 정보를 조회

### 구현

```tsx
// stores/selection.ts
import { atom } from 'jotai';

// 현재 선택된 주식 심볼 (null이면 선택 안 됨)
export const selectedStockSymbolAtom = atom<string | null>(null);
```

```tsx
// hooks/useSelectedStock.ts
import { useAtomValue } from 'jotai';
import { useQuery } from '@tanstack/react-query';

export function useSelectedStock() {
  const symbol = useAtomValue(selectedStockSymbolAtom);
  
  return useQuery({
    queryKey: ['stock', 'detail', symbol],
    queryFn: () => stocksApi.getBySymbol(symbol!),
    
    // ⭐ 핵심: symbol이 있을 때만 쿼리 실행
    enabled: !!symbol,
  });
}
```

**`enabled: !!symbol`의 의미:**
- `symbol`이 `null`이면 쿼리가 **실행되지 않음**
- `symbol`이 설정되면 즉시 쿼리 실행
- 불필요한 API 호출 방지

```tsx
// components/StockDetail.tsx
function StockDetail() {
  const { data: stock, isLoading, error } = useSelectedStock();
  const symbol = useAtomValue(selectedStockSymbolAtom);
  
  // 선택된 주식 없음
  if (!symbol) {
    return (
      <div className="empty-state">
        <p>주식을 선택해주세요</p>
      </div>
    );
  }
  
  if (isLoading) return <DetailSkeleton />;
  if (error) return <Error message={error.message} />;
  
  return (
    <div>
      <h2>{stock.name} ({stock.symbol})</h2>
      <p>현재가: ${stock.price}</p>
      <p>변동: {stock.changePercent}%</p>
      {/* ... */}
    </div>
  );
}
```

```tsx
// components/StockItem.tsx
function StockItem({ stock }: { stock: Stock }) {
  const [selectedSymbol, setSelectedSymbol] = useAtom(selectedStockSymbolAtom);
  
  const isSelected = selectedSymbol === stock.symbol;
  
  return (
    <li
      onClick={() => setSelectedSymbol(stock.symbol)}
      className={isSelected ? 'selected' : ''}
    >
      {stock.symbol} - ${stock.price}
    </li>
  );
}
```

---

## 패턴 3: 파생 Atom으로 서버 데이터 가공

### 시나리오

서버에서 받은 주식 데이터를 클라이언트에서 추가 가공:
- 필터링
- 정렬
- 통계 계산

### 왜 파생 Atom을 사용하나요?

```tsx
// ❌ 좋지 않은 방법: 컴포넌트에서 매번 계산
function StockStats() {
  const { data: stocks } = useStocks();
  
  // 렌더링마다 재계산 (다른 컴포넌트에서도 같은 계산 반복)
  const avgPrice = stocks?.reduce((sum, s) => sum + s.price, 0) / stocks?.length;
  const topGainer = stocks?.sort((a, b) => b.changePercent - a.changePercent)[0];
}
```

```tsx
// ✅ 좋은 방법: 파생 Atom으로 계산 결과 공유
// stores/stockStats.ts
import { atom } from 'jotai';

// 주식 데이터를 담는 atom (TanStack Query 결과를 여기에 동기화)
export const stocksDataAtom = atom<Stock[]>([]);

// 파생: 평균 가격
export const avgPriceAtom = atom((get) => {
  const stocks = get(stocksDataAtom);
  if (stocks.length === 0) return 0;
  return stocks.reduce((sum, s) => sum + s.price, 0) / stocks.length;
});

// 파생: 상승률 TOP 5
export const topGainersAtom = atom((get) => {
  const stocks = get(stocksDataAtom);
  return [...stocks]
    .sort((a, b) => b.changePercent - a.changePercent)
    .slice(0, 5);
});

// 파생: 섹터별 그룹화
export const stocksBySectorAtom = atom((get) => {
  const stocks = get(stocksDataAtom);
  return stocks.reduce((acc, stock) => {
    const sector = stock.sector || 'Other';
    if (!acc[sector]) acc[sector] = [];
    acc[sector].push(stock);
    return acc;
  }, {} as Record<string, Stock[]>);
});
```

**TanStack Query 결과를 Jotai에 동기화:**

```tsx
// hooks/useSyncStocksToAtom.ts
import { useSetAtom } from 'jotai';
import { useQuery } from '@tanstack/react-query';
import { stocksDataAtom } from '@/stores/stockStats';
import { useEffect } from 'react';

export function useSyncStocksToAtom() {
  const setStocksData = useSetAtom(stocksDataAtom);
  
  const query = useQuery({
    queryKey: ['stocks'],
    queryFn: stocksApi.getAll,
  });
  
  // 쿼리 결과를 atom에 동기화
  useEffect(() => {
    if (query.data) {
      setStocksData(query.data);
    }
  }, [query.data, setStocksData]);
  
  return query;
}
```

---

## 패턴 4: jotai-tanstack-query 통합 라이브러리

### 개념

Jotai 팀에서 제공하는 공식 통합 라이브러리입니다. Query와 Atom을 더 자연스럽게 결합합니다.

### 설치

```bash
npm install jotai-tanstack-query
```

### 사용법

```tsx
import { atomWithQuery, atomWithMutation } from 'jotai-tanstack-query';

// Query를 Atom으로 정의
const usersAtom = atomWithQuery(() => ({
  queryKey: ['users'],
  queryFn: getUsers,
}));

// 사용 - 일반 atom처럼!
function UserList() {
  const [{ data, isPending, isError }] = useAtom(usersAtom);
  
  if (isPending) return <Loading />;
  if (isError) return <Error />;
  
  return (
    <ul>
      {data.map(user => <li key={user.id}>{user.name}</li>)}
    </ul>
  );
}
```

**장점:**
- Jotai의 `useAtom` 훅만으로 서버 데이터 접근
- 파생 atom에서 쿼리 결과 활용 가능
- 일관된 상태 관리 패턴

```tsx
// 파생 atom에서 쿼리 결과 사용
const userCountAtom = atom((get) => {
  const { data } = get(usersAtom);
  return data?.length ?? 0;
});

// 조건부 쿼리
const userDetailAtom = atomWithQuery((get) => {
  const userId = get(selectedUserIdAtom);
  return {
    queryKey: ['user', userId],
    queryFn: () => getUser(userId!),
    enabled: !!userId,
  };
});
```

---

## 활용 팁

### 1. 역할 분담 체크리스트

새로운 상태를 추가할 때:

| 질문 | Jotai | TanStack Query |
|------|-------|----------------|
| 서버에서 오는 데이터인가? | | ✅ |
| UI 표시/숨김 상태인가? | ✅ | |
| 여러 컴포넌트에서 필터로 사용되는가? | ✅ | |
| 캐싱/재시도가 필요한가? | | ✅ |
| 서버와 동기화해야 하는가? | | ✅ |

### 2. 흔한 실수 피하기

```tsx
// ❌ 실수: TanStack Query 결과를 Jotai에 복사만 함
const usersAtom = atom<User[]>([]);

function UserList() {
  const [, setUsers] = useAtom(usersAtom);
  
  useEffect(() => {
    fetch('/api/users')
      .then(r => r.json())
      .then(setUsers);
    // 문제: 캐싱, 로딩 상태, 에러 처리, 재시도 등 직접 구현해야 함
  }, []);
}

// ✅ 올바른 사용: 각 도구의 역할에 맞게 사용
// 서버 데이터 → TanStack Query
// UI 상태 (필터, 선택 등) → Jotai
```

### 3. 커스텀 훅으로 패턴 캡슐화

```tsx
// hooks/useFilteredStocks.ts
export function useFilteredStocks() {
  // 필터 상태 (Jotai)
  const exchange = useAtomValue(exchangeFilterAtom);
  const sector = useAtomValue(sectorFilterAtom);
  
  // 서버 데이터 (TanStack Query)
  const query = useQuery({
    queryKey: ['stocks', { exchange, sector }],
    queryFn: () => stocksApi.getAll({ exchange, sector }),
  });
  
  return {
    ...query,
    // 추가 유틸리티
    isEmpty: query.data?.length === 0,
    total: query.data?.length ?? 0,
  };
}
```

---

## 레퍼런스

- [jotai-tanstack-query](https://jotai.org/docs/extensions/query)
- [Jotai - Third Party Extensions](https://jotai.org/docs/third-party/integration)
- [TanStack Query - React Integration](https://tanstack.com/query/latest/docs/framework/react/overview)
